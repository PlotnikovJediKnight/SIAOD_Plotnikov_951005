#include <iostream>
#include <string>
using namespace std;

//СИАОД, Лабораторная работа №1
//Задача №1
//Многочлены

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Класс-многочлен
class Polynomial {
private:
	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Структура для хранения одночлена
	struct Monomial {
		int power;			//Показатель степени
		int coeff;			//Коэффициент одночлена
		Monomial* next;		//Указатель на следующий одночлен

		//Явный конструктор инициализации
		explicit Monomial(int pow, int k) {
			power = pow;
			coeff = k;
			next = nullptr;
		}
	};
	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	Monomial* head;			//Указатель на первый одночлен
	int size;				//Количество одночленов в многочлене

public:

	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//Явный конструктор инициализации (пустой многочлен)
	explicit Polynomial() {
		head = nullptr;
		size = 0;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Конструктор копирования
	Polynomial(const Polynomial& obj) {
		//Создаем пустой многочлен
		head = nullptr;
		size = 0;
		
		//Становимся в начало многочлена, который хотим скопировать
		Monomial* curr = obj.head;
		while (curr != nullptr) {
			//Добавляем одночлен из obj в многочлен this
			this->addNewMonomial(curr->power, curr->coeff);
			//Переходим к следующему
			curr = curr->next;
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//Перегрузка оператора "равно". Проверяет равенство многочленов
	bool operator==(const Polynomial& obj) {
		//Многочлены не равны, если в них входит разное количество одночленов
		if (obj.size != this->size) return false;

		//Становимся в начало каждого из многочленов
		Monomial* curr1 = head;
		Monomial* curr2 = obj.head;

		//Движемся вперед, покуда все параметры равны
		while (curr1->power == curr2->power &&
			   curr1->coeff == curr2->coeff) {
			curr1 = curr1->next;
			curr2 = curr2->next;
			
			//Дошли до самого конца - многочлены равны. Возвращаем true.
			if ((curr1 == curr2) && (curr1 == nullptr)) return true;
		}

		//Многочлены не равны, так как было не выполнено условие в while. Возвращаем false.
		return false;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Перегрузка оператора "плюс". Складывает два многочлена и возвращает новый
	Polynomial operator+(const Polynomial& obj) {
		//Копируем многочлен (левый операнд)
		Polynomial result(*this);

			//Становимся в начало многочлена (правый операнд)
			Monomial* curr = obj.head;
			while (curr != nullptr) {
				//Добавляем одночлен из правого операнда в результатный многочлен
				result.addNewMonomial(curr->power, curr->coeff);
				curr = curr->next;
			}
		//Возвращаем многочлен-сумму
		return result;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Добавление одночлена в многочлен (добавление элемента в список)
	void addNewMonomial(int pow, int val) {
		//Одночлены с коэффициентом "ноль" в список не заносим
		if (val == 0) return;

		//Создаем одночлен ("узел")
		Monomial* obj = new Monomial(pow, val);

		//Если многочлен ("список") пуст, то просто запоминаем новое начало ("голову")
		if (isEmpty()) {
			head = obj;
			size++;
		}
		else
			//Если голова есть, но степень у неё равна степени
			//одночлена, который мы хотим вставить
			if (head->power == obj->power) {
				//Увеличиваем коэффициент уже существующего узла
				head->coeff += obj->coeff;
				//Если коэффициент головы стал равен нулю, необходимо
				//удалить старую голову и назначить новую
				if (head->coeff == 0) {
					Monomial* toDelete = head;
					head = head->next;
					delete toDelete;
					size--;
				}
				//Удаляем obj ("узел")
				delete obj;
			}
			else
				//Если голова есть, но степень у неё меньше степени
				//одночлена, который мы хотим вставить
				if (head->power < obj->power) {
					//Теперь одночлен будет ссылаться на старую голову
					obj->next = head;
					//Меняем голову
					head = obj;
					size++;
				}
				//Голову не будет необходимости менять.
				//Вставка произойдет либо в середине, либо в конце списка
				else {

					//Становимся в начало
					Monomial* curr = head;
					Monomial* prev = curr;
					//Идем вперед, покуда не наткнулись на конец либо на место вставки
					//(одночлены отсортированы в списке по убыванию степени)
					while (curr != nullptr && curr->power > obj->power) {
						//Запоминаем предыдущего
						prev = curr;
						curr = curr->next;
					}

					//Дошли до самого конца списка
					if (curr == nullptr) {
						//Последний член списка должен ссылаться на вставляемый (после этого obj станет последним)
						prev->next = obj;
						size++;
					}
					//Вставка происходит в середине
					else
						//Просто обновляем коэффициент у уже существующего одночлена
						if (curr->power == obj->power) {
							curr->coeff += obj->coeff;
							//Удаляем, если коэффициент стал равен нулю
							if (curr->coeff == 0) {

								Monomial* toDelete = curr;
								prev->next = curr->next;
								delete toDelete;
								size--;
							}
							//Удаляем узел
							delete obj;
						}
						//Обнаружено место вставки для obj. Необходимо
						//поменять ссылки (prev -> obj -> next).
						else {
							obj->next = curr;
							prev->next = obj;
							size++;
						}

				}

	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Рассчитываем значение многочлена в целочисленной точке
	double getValueAtX(int x) {
		double res = 0;
			//Становимся в начало многочлена
			Monomial* curr = head;
			while (curr != nullptr) {
				//Накапливаем сумму
				res += pow(x, curr->power) * curr->coeff;
				curr = curr->next;
			}
		//Возвращаем результат
		return res;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Составление строкового представления многочлена
	string getStringRepresentation() const {
		//Возвращаем "ноль", если многочлен пуст
		if (isEmpty()) return "0";
		else {
			string buf;
			//Становимся в начало многочлена
			Monomial* curr = head;
			while (curr != nullptr) {
				//Накапливаем строки
				if (curr->next == nullptr)
					buf += "(" + to_string(curr->coeff) + ")x^" + "(" + to_string(curr->power) + ")";
				else
					buf += "(" + to_string(curr->coeff) + ")x^" + "(" + to_string(curr->power) + ") + ";
				curr = curr->next;
			}
			//Возвращаем результат
			return buf;
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Многочлен пуст?
	bool isEmpty() const { return (size == 0); }

	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Деструктор
	~Polynomial() {
		Monomial* curr = head;
		Monomial* prev = curr;

		//Удаляем все одночлены из многочлена
		while (curr != nullptr) {
			prev = curr;
			curr = curr->next;
			delete prev;
		}

		head = nullptr;
		size = 0;
	}
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Перегрузка оператора >> для потокового ввода
istream& operator>> (istream& in, Polynomial& p) {

	cout << "Ввод многочлена вида a[n]*x^[n] + a[n-1]*x^[n-1] + ... + a0." << endl;

	int N = -1;
		
	cout << "Введите N: " << endl;
	cin >> N;

	int coeff = -1;

	for (int i = N; i >= 0; i--) {
		cout << "Введите коэффициент a[" << i << "]:" << endl;
		cin >> coeff;

		p.addNewMonomial(i, coeff);
	}

	return in;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Перегрузка оператора << для потокового вывода
ostream& operator<< (ostream& out, const Polynomial& p) {
	out << p.getStringRepresentation();
	return out;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main() {
	setlocale(LC_ALL, "RUS");
	
	//Создаем два многочлена
	Polynomial A, B;

	//Ввод первого многочлена
	cin >> A;
	//Ввод второго многочлена
	cin >> B;

	cout << "Многочлен А: " << A << endl;
	cout << "Многочлен B: " << B << endl;
	cout << "Сумма А + B: " << A + B << endl;
	cout << "Результат А(2): " << A.getValueAtX(2) << endl;
	cout << "Результат B(0): " << B.getValueAtX(0) << endl;
	cout << "A равно B: " << (A == B) << endl;

	
	return 0;
}